import random
from enum import Enum
from typing import List
import localizator
from bot import MasterBot
from text_generator import TextGenerator


class Player() :
    """
    Class represents a player in a game
    """
    def __init__(self, chat_id : int, bot : MasterBot) -> None:
        self.chat_id = chat_id
        self.bot = bot
        self.is_playing = False
        self.game = None
        self.points = 0
        self.state = PlayerStates.NONE
        bot.add_listener(self._on_message)
    
    def notify_user(self, message : str) -> None:
        """
        Sends a message to user
        """
        self.bot.send_message(message ,self.chat_id)

    def _on_message(self, chat_id : int, content : str) :
        """
        Bot calls this method when user send any message
        """
        
        #Check - Is user owns this player
        if self.chat_id != chat_id :
            return
        if self.state == PlayerStates.WAIT_FOR_TEXT_FRAGMENT :
            self.game.submit_fragment(content)
        elif self.state == PlayerStates.WAIT_FOR_USER_TEXT :
            self.game.submit_user_text(content)
        elif self.state == PlayerStates.WAIT_FOR_GUESSING_TEXT :
            try :
                self.game.guess_user_text(int(content))
            except :
                self.notify_user(localizator.PHRASE_INDEX_ERROR[self.game.localization])
    def kick_from_game(self) :
        """
        Kicks a player from the current game
        """
        self.game = None
        self.points = 0
        self.is_playing = False
        self.state = PlayerStates.NONE
    
    def get_name(self) :
        """
        Returns the name of player
        """
        return self.bot.user_name_by_chat_id(self.chat_id)


class Game() :
    """
    Class that represents the game and contains all game logic
    """
    def __init__(self, game_name : str, pass_code : str, max_turns : str, localization : str, number_of_generated_texts : int, text_generators : List[TextGenerator]) -> None:
        """
        Constucts a game. Requires a game name, pass code, maximum number of turns, localization, number of texts generated by text generator, and generators of text themselves
        """
        self._init_game()
        
        self.game_name = game_name
        self.pass_code = pass_code
        self.max_turns = max_turns
        self.localization = localization
        self.number_of_generated_texts = number_of_generated_texts
        self.text_generators = text_generators

    def add_player(self, player : Player) -> None :
        """
        Adds player to a game
        """
        player.is_playing = True
        player.game = self
        if self.detective_player :
            self.imposter_player = player
            self._send_to_all(localizator.PHRASE_GAME_START[self.localization])
            self.game_started = True
            self._start_game()
        else :
            self.detective_player = player
    
    def submit_fragment(self, sentence : str) -> None :
        """
        Gets a fragment of the text from user        
        """

        self.part_text = sentence
        self.detective_player.notify_user(localizator.PHRASE_ASK_FOR_COMPLETE_TEXT_WAITING[self.localization])
        self.ai_texts = self.roll_texts()
        ai_texts_string = ""
        for text in self.ai_texts :
            ai_texts_string += self.part_text + text + "\n----------\n"
        self.imposter_player.notify_user(ai_texts_string)
        self.imposter_player.notify_user(localizator.PHRASE_ASK_FOR_COMPLETE_TEXT[self.localization] + self.part_text)
        self.imposter_player.state = PlayerStates.WAIT_FOR_USER_TEXT
        self.detective_player.state = PlayerStates.NONE

    def submit_user_text(self, text : str) -> None :
        """
        Gets the complete text from user        
        """
        
        self.imposter_player.notify_user(localizator.PHRASE_ASK_FOR_GUESS_WAITING[self.localization])
        self.shuffled_texts = self.ai_texts
        self.user_text = text
        self.shuffled_texts.append(self.user_text)
        random.shuffle(self.shuffled_texts)
        texts_for_detective = ""
        for i in range(len(self.shuffled_texts)) :
            if self.user_text == self.shuffled_texts[i] : #Adding user text without adding a fragment (because of beginning spaces)
                texts_for_detective += str(i+1)+ ":\n" + self.shuffled_texts[i] + "\n"
                continue
            texts_for_detective += str(i+1)+ ":\n" + self.part_text + self.shuffled_texts[i] + "\n"
        self.detective_player.notify_user(texts_for_detective + "\n" + localizator.PHRASE_ASK_FOR_GUESS[self.localization])
        self.imposter_player.state = PlayerStates.NONE
        self.detective_player.state = PlayerStates.WAIT_FOR_GUESSING_TEXT

    def guess_user_text(self, text_id : int) -> None :
        """
        Checks user's guess and calculates points   
        """

        if self.shuffled_texts[text_id-1] == self.user_text :
            self.detective_player.points += 1
            self.detective_player.notify_user(localizator.PHRASE_SUCCESS[self.localization])
            self.imposter_player.notify_user(localizator.PHRASE_UNSUCCESS_HIDE[self.localization])
        else :
            self.detective_player.notify_user(localizator.PHRASE_UNSUCCESS[self.localization])
            self.imposter_player.notify_user(localizator.PHRASE_SUCCESS_HIDE[self.localization])
        
        if self.turn < self.max_turns :
            self._send_to_all(localizator.PHRASE_ROUND_ENDS[self.localization])
            self._swap_role()
        else :
            self._finish_game()
    

    def roll_texts(self) -> List[str] :
        """
        Loads the text from AI
        """
        return self.text_generators[self.turn % len(self.text_generators)].get_text(self.part_text, self.number_of_generated_texts)
    
    def _start_game(self) -> None :
        """
        Starts a game!
        """
        
        self.detective_player.notify_user(localizator.PHRASE_ASK_FOR_FRAGMENT[self.localization])
        self.detective_player.state = PlayerStates.WAIT_FOR_TEXT_FRAGMENT
        self.imposter_player.notify_user(localizator.PHRASE_ASK_FOR_FRAGMENT_WAITING[self.localization])
        self.imposter_player.state = PlayerStates.NONE
    
    def _finish_game(self) -> None :
        """
        Calculates the winner and finishes the game
        """
        if self.detective_player.points > self.imposter_player.points :
            self._send_to_all(localizator.PHRASE_GAME_WINNER[self.localization] + str(self.detective_player.get_name()))
        elif self.imposter_player.points > self.detective_player.points :
            self._send_to_all(localizator.PHRASE_GAME_WINNER[self.localization] + str(self.imposter_player.get_name()))
        else :
            self._send_to_all(localizator.PHRASE_GAME_DRAW[self.localization])
        self.imposter_player.kick_from_game()
        self.detective_player.kick_from_game()
        self._init_game()


    def _send_to_all(self, message : str) -> None :
        """
        Sends one message to all players
        """
        self.imposter_player.notify_user(message)
        self.detective_player.notify_user(message)
    
    def _swap_role(self) -> None :
        """
        Swaps roles of players
        """
        temp = self.imposter_player
        self.imposter_player = self.detective_player
        self.detective_player = temp
        self.turn += 1
        self._start_game()

    def _init_game(self) :
        """
        Resets/sets all game parameters
        """
        self.imposter_player = None
        self.detective_player = None
        self.user_text = None
        self.part_text = None
        self.shuffled_texts = None
        self.ai_texts = None
        self.game_started = False
        self.turn = 1

class Lobby() :
    """
    Class that controlls the process of players joining the games.
    """

    def __init__(self, bot : MasterBot, games : List[Game]) -> None:
        """
        Initialize the instance of Lobby class.
        Requires a bot for communication with players and the list of available games.
        """
        self.bot = bot
        self.games = games

        self.users = []
        self.bot.add_listener(self._on_message)
 
    def _on_message(self, chat_id : int, content : str) -> None :
        """
        Bot calls this method when user send any message
        """
        user = self.find_user_by_chat_id(chat_id)
        
        if user and not user.is_playing :
            for game in self.games :
                if game.pass_code == content and not game.game_started :
                    game.add_player(user)
                    return
            if not user.is_playing :
                self._show_avaible_games(chat_id)
        elif not user :
            new_user = Player(chat_id, self.bot)
            self.users.append(new_user)

            for game in self.games :
                if game.pass_code == content and not game.game_started :
                    game.add_player(new_user)
                    return
            self._show_avaible_games(chat_id)

    def find_user_by_chat_id(self, chat_id : int) -> None :
        """
        Finds a user with specific chat_id, if there is any.
        If user was not found returns None
        """
        for user in self.users :
            if user.chat_id == chat_id :
                return user
        return None
    
    def _show_avaible_games(self, chat_id : int) -> None :
        """
        Shows the available games (in-game we call them servers) for user.
        """
        list_of_servers = "Available servers:\n"
        for i in range(len(self.games)) :
            if self.games[i].game_started :
                continue
            list_of_servers += str(i+1) + "." + self.games[i].game_name + ", code: " + self.games[i].pass_code + "\n"
        list_of_servers += "\nEnter server code to connect"
        self.bot.send_message(list_of_servers, chat_id)

class PlayerStates(Enum) :
    """
    All game states of a player
    """

    WAIT_FOR_TEXT_FRAGMENT = "Wait for text fragment"
    WAIT_FOR_USER_TEXT = "Wait for user text"
    WAIT_FOR_GUESSING_TEXT = "Wait for guessing text"
    NONE = "None"
